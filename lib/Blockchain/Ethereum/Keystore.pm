package Blockchain::Ethereum::Keystore;

use v5.26;
use strict;
use warnings;

use File::Slurp;
use JSON::MaybeXS qw(decode_json);
use Crypt::PBKDF2;
use Crypt::ScryptKDF qw(scrypt_raw);
use Crypt::PRNG;
use Net::SSH::Perl::Cipher;

my %cipher = (
    'aes-128-ctr' => 'AES128_CTR',
    'aes-128-ctb' => 'AES128_CBC',
);

my %kdf_hash_class = ('hmac-sha256' => 'HMACSHA2');

sub new {
    return bless {}, shift;
}

sub json {
    my $self = shift;
    return $self->{json_utf8} //= JSON::MaybeXS->new(utf8 => 1);
}

sub private_key_from_keyfile {
    my ($self, $file_path, $password) = @_;

    my $content = read_file($file_path);
    my $decoded = json->decode($content);

    return $self->private_key_from_keyobject($decoded, $password);
}

sub private_key_from_keyobject {
    my ($self, $object, $password) = @_;

    my $crypto     = $object->{crypto};
    my $kdf_params = $crypto->{kdfparams};

    my $kdf_function = '_decode_kdf_' . $crypto->{kdf};
    my $derived_key  = $self->$kdf_function($kdf_params, $password);

    my $cipher = Net::SSH::Perl::Cipher->new(
        $cipher{$crypto->{cipher}},    #
        $derived_key,
        pack("H*", $crypto->{cipherparams}->{iv}));

    return $cipher->decrypt(pack "H*", $crypto->{ciphertext});
}

sub keyfile_from_private_key {
    my ($self, $private_key, $password, $salt) = @_;

    my $file = {
        "crypto" => {
            "cipher"       => "aes-128-ctr",
            "cipherparams" => {"iv" => undef},
            "ciphertext"   => undef,
            "kdf"          => "scrypt",
            "kdfparams"    => {
                "dklen" => undef,
                "n"     => undef,
                "p"     => undef,
                "r"     => undef,
                "salt"  => undef
            },
            "mac" => undef
        },
        "id"      => "3198bc9c-6672-5ab3-d995-4942343ae5b6",
        "version" => 3
    };

    my $crypto = $file->{crypto};

    my @params = ($password);
    push @params, $salt if $salt;

    # use the internal method here otherwise would not be availble to get the kdf params
    # salt if give will be the same as the response, if not will be auto generated by the library
    my ($derived_key, $N, $r, $p);
    ($derived_key, $salt, $N, $r, $p) = Crypt::ScryptKDF::_scrypt_extra(@params);

    my $kdf_params = $crypto->{kdfparams};
    $kdf_params->{dklen} = length $derived_key;
    $kdf_params->{n}     = $N;
    $kdf_params->{p}     = $p;
    $kdf_params->{r}     = $r;
    $kdf_params->{salt}  = unpack "H*", $salt;

    my $iv = Crypt::PRNG::random_bytes(16);
    $crypto->{cipherparams}->{iv} = unpack "H*", $iv;

    my $cipher = Net::SSH::Perl::Cipher->new(
        $cipher{$crypto->{cipher}},    #
        $derived_key,
        $iv);

    my $encrypted = $cipher->encrypt(pack "H*", $private_key);

    $crypto->{ciphertext} = unpack "H*", $encrypted;

    return $file;
}

sub _decode_kdf_pbkdf2 {
    my ($self, $kdf_params, $password) = @_;

    my $derived_key = Crypt::PBKDF2->new(
        hash_class => $kdf_hash_class{$kdf_params->{prf}},
        iterations => $kdf_params->{c},
        output_len => $kdf_params->{dklen},
    )->PBKDF2(pack("H*", $kdf_params->{salt}), $password);

    return $derived_key;
}

sub _decode_kdf_scrypt {
    my ($self, $kdf_params, $password) = @_;

    my $derived_key = scrypt_raw(
        $password,    #
        pack("H*", $kdf_params->{salt}),
        $kdf_params->{n},
        $kdf_params->{r},
        $kdf_params->{p},
        $kdf_params->{dklen});

    return $derived_key;
}

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

Blockchain::Ethereum::Keystore - The great new Blockchain::Ethereum::Keystore!

=head1 VERSION

Version 0.001

=cut

our $VERSION = '0.001';


=head1 SYNOPSIS

Quick summary of what the module does.

Perhaps a little code snippet.

    use Blockchain::Ethereum::Keystore;

    my $foo = Blockchain::Ethereum::Keystore->new();
    ...

=head1 EXPORT

A list of functions that can be exported.  You can delete this section
if you don't export anything, such as for a purely object-oriented module.

=head1 METHODS

=head2 function1

=cut

sub function1 {
}

=head2 function2

=cut

sub function2 {
}

=head1 AUTHOR

Reginaldo Costa, C<< <refeco at cpan.org> >>

=head1 BUGS

Please report any bugs or feature requests to L<https://github.com/refeco/perl-ethereum-keystore>

=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Blockchain::Ethereum::Keystore

=head1 LICENSE AND COPYRIGHT

This software is Copyright (c) 2023 by REFECO.

This is free software, licensed under:

  The MIT License

=cut
